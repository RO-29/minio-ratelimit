global
    daemon
    maxconn 4096
    log stdout local0 info

    # Lua scripts for S3 API key extraction and dynamic rate limiting
    lua-load /usr/local/etc/haproxy/extract_api_keys.lua
    lua-load /usr/local/etc/haproxy/dynamic_rate_limiter.lua

    # Stats socket for runtime API (Docker-friendly path)
    stats socket /tmp/haproxy.sock mode 666 level admin
    stats timeout 30s

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms
    option httplog
    log global

# Frontend for S3 API requests with complete authentication support
frontend s3_frontend
    bind *:80
    bind *:443 ssl crt /etc/ssl/certs/haproxy.pem

    # Extract API key from multiple S3 authentication methods using Lua
    # The Lua script handles all auth methods: V2, V4, pre-signed URLs, custom headers
    http-request lua.extract_api_key

    # Dynamic API key to group mapping using map file (hot-reloadable)
    http-request set-var(txn.rate_group) var(txn.api_key),map(/usr/local/etc/haproxy/config/api_key_groups.map,unknown)

    # Fallback: Default to basic for test keys only if map lookup failed
    http-request set-var(txn.rate_group) str(basic) if { var(txn.rate_group) -m str unknown } { var(txn.api_key) -m beg test- }

    # Dynamic rate limits from map files (hot-reloadable)
    http-request set-var(txn.rate_limit_per_minute) var(txn.rate_group),map(/usr/local/etc/haproxy/config/rate_limits_per_minute.map,50)
    http-request set-var(txn.rate_limit_per_second) var(txn.rate_group),map(/usr/local/etc/haproxy/config/rate_limits_per_second.map,5)
    http-request set-var(txn.error_message) var(txn.rate_group),map(/usr/local/etc/haproxy/config/error_messages.map,Rate_limit_exceeded)

    # Track requests per API key (individual rate limiting)
    http-request track-sc0 var(txn.api_key) table api_key_rates_1m
    http-request track-sc1 var(txn.api_key) table api_key_rates_1s

    # Dynamic rate limiting using Lua script - no hardcoded ACLs needed
    # FULLY DYNAMIC RATE LIMITING: All limits come from map files
    # No hardcoded values - limits are checked dynamically using Lua script

    # Check rate limits using dynamic Lua function
    http-request lua.check_rate_limit

    # Deny request if rate limit exceeded (determined by Lua script)
    http-request deny deny_status 429 content-type "application/xml" string "%[var(txn.rate_limit_error)]" if { var(txn.rate_limit_exceeded) -m str true }


    # Response headers for rate limiting information
    http-response set-header X-RateLimit-Group "%[var(txn.rate_group)]"
    http-response set-header X-API-Key "%[var(txn.api_key)]"
    http-response set-header X-Auth-Method "%[var(txn.auth_method)]"

    # Dynamic rate limit headers
    http-response set-header X-RateLimit-Limit-Per-Minute "%[var(txn.rate_limit_per_minute)]"
    http-response set-header X-RateLimit-Limit-Per-Second "%[var(txn.rate_limit_per_second)]"

    http-response set-header X-RateLimit-Current-Per-Minute "%[sc_http_req_rate(0)]"
    http-response set-header X-RateLimit-Current-Per-Second "%[sc_http_req_rate(1)]"
    http-response set-header X-RateLimit-Reset "%[date(),add(3600)]"

    default_backend minio_backend

# Backend for MinIO cluster
backend minio_backend
    balance roundrobin

    # MinIO server instances
    server minio1 minio:9000

# Stick tables for individual API key rate tracking (no shared limits)
backend api_key_rates_1m
    stick-table type string len 64 size 100k expire 2m store http_req_rate(1m),http_req_cnt,http_err_rate(1m)

backend api_key_rates_1s
    stick-table type string len 64 size 100k expire 10s store http_req_rate(1s),http_req_cnt

# Stats interface for monitoring
listen stats
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 30s
    stats admin if TRUE
    stats show-legends
    stats show-desc "HAProxy MinIO Complete Rate Limiting - Individual API Key Tracking"
