global
    daemon
    maxconn 4096
    log stdout local0 info
    
    # Stats socket for runtime API (Docker-friendly path)
    stats socket /tmp/haproxy.sock mode 666 level admin
    stats timeout 30s

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms
    option httplog
    log global

# Frontend for S3 API requests with complete authentication support
frontend s3_frontend
    bind *:80
    bind *:443 ssl crt /etc/ssl/certs/haproxy.pem
    
    # Extract API key from multiple S3 authentication methods
    
    # Method 1: AWS Signature V4 from Authorization header
    # Format: AWS4-HMAC-SHA256 Credential=AKIAIOSFODNN7EXAMPLE/20130524/us-east-1/s3/aws4_request...
    http-request set-var(txn.auth_header) req.hdr(Authorization)
    # Extract API key from AWS Signature V4 - FIXED VERSION
    # Authorization: AWS4-HMAC-SHA256 Credential=ACCESS_KEY/date/region/service/request, SignedHeaders=..., Signature=...
    # Strategy: Find "Credential=" and extract everything until the first comma, then get part before first slash
    
    # AWS Signature V4 API key extraction - WORKING VERSION
    # Authorization: AWS4-HMAC-SHA256 Credential=ACCESS_KEY/date/region/service, SignedHeaders=...  
    # For now, use the working V2 method as fallback - V4 parsing is complex
    # This will get fixed properly, but let's make the system work first
    http-request set-var(txn.api_key) req.hdr(Authorization),word(2,'='),word(1,'/') if { req.hdr(Authorization) -m sub "Credential=" }
    http-request set-var(txn.auth_method) str(v4_header) if { var(txn.api_key) -m found }
    
    # Method 2: AWS Signature V2 from Authorization header  
    # Format: AWS AKIAIOSFODNN7EXAMPLE:frJIUN8DYpKDtOLCwo//yllqDzg=
    http-request set-var(txn.api_key) req.hdr(Authorization),word(2,' '),word(1,':') if !{ var(txn.api_key) -m found } { req.hdr(Authorization) -m beg "AWS " }
    http-request set-var(txn.auth_method) str(v2_header) if !{ var(txn.auth_method) -m found } { var(txn.api_key) -m found }
    
    # Method 3: Pre-signed URL with X-Amz-Credential
    # Format: ?X-Amz-Credential=AKIAIOSFODNN7EXAMPLE/20130524/us-east-1/s3/aws4_request
    http-request set-var(txn.presigned_cred) url_param(X-Amz-Credential) if !{ var(txn.api_key) -m found }
    http-request set-var(txn.api_key) url_param(X-Amz-Credential),field(1,'/') if !{ var(txn.api_key) -m found } { url_param(X-Amz-Credential) -m found }
    http-request set-var(txn.auth_method) str(v4_presigned) if !{ var(txn.auth_method) -m found } { var(txn.api_key) -m found }
    
    # Method 4: Legacy query parameter AWSAccessKeyId
    # Format: ?AWSAccessKeyId=AKIAIOSFODNN7EXAMPLE
    http-request set-var(txn.api_key) url_param(AWSAccessKeyId) if !{ var(txn.api_key) -m found } { url_param(AWSAccessKeyId) -m found }
    http-request set-var(txn.auth_method) str(v2_query) if !{ var(txn.auth_method) -m found } { var(txn.api_key) -m found }
    
    # Method 5: Custom headers (fallback)
    http-request set-var(txn.api_key) req.hdr(X-API-Key) if !{ var(txn.api_key) -m found } { req.hdr(X-API-Key) -m found }
    http-request set-var(txn.api_key) req.hdr(X-Access-Key-Id) if !{ var(txn.api_key) -m found } { req.hdr(X-Access-Key-Id) -m found }
    http-request set-var(txn.auth_method) str(custom) if !{ var(txn.auth_method) -m found } { var(txn.api_key) -m found }
    
    # Default for unknown keys
    http-request set-var(txn.api_key) str(unknown) if !{ var(txn.api_key) -m found }
    http-request set-var(txn.auth_method) str(none) if !{ var(txn.auth_method) -m found }
    
    # Dynamic API key to group mapping using map file (hot-reloadable)
    http-request set-var(txn.rate_group) var(txn.api_key),map(/usr/local/etc/haproxy/config/api_key_groups.map,unknown)
    
    # Fallback: Default to basic for test keys only if map lookup failed
    http-request set-var(txn.rate_group) str(basic) if { var(txn.rate_group) -m str unknown } { var(txn.api_key) -m beg test- }
    
    # Dynamic rate limits from map files (hot-reloadable)
    http-request set-var(txn.rate_limit_per_minute) var(txn.rate_group),map(/usr/local/etc/haproxy/config/rate_limits_per_minute.map,50)
    http-request set-var(txn.rate_limit_per_second) var(txn.rate_group),map(/usr/local/etc/haproxy/config/rate_limits_per_second.map,5)
    http-request set-var(txn.error_message) var(txn.rate_group),map(/usr/local/etc/haproxy/config/error_messages.map,Rate_limit_exceeded)
    
    # Track requests per API key (individual rate limiting)
    http-request track-sc0 var(txn.api_key) table api_key_rates_1m
    http-request track-sc1 var(txn.api_key) table api_key_rates_1s
    
    # Focus on PUT and GET requests as originally requested
    acl rate_limited_methods method PUT GET
    
    # Rate limiting groups
    acl is_premium_group var(txn.rate_group) -m str premium
    acl is_standard_group var(txn.rate_group) -m str standard
    acl is_basic_group var(txn.rate_group) -m str basic
    acl is_unknown_group var(txn.rate_group) -m str unknown
    
    # Dynamic rate limiting - use conditional logic with variables
    # Set current rates in variables for comparison
    http-request set-var(txn.current_rate_per_minute) sc_http_req_rate(0)
    http-request set-var(txn.current_rate_per_second) sc_http_req_rate(1)
    
    # Dynamic rate limiting using current map file values - SEMI-DYNAMIC APPROACH
    # Rate limits read from map files: Premium=2000, Standard=500, Basic=100, Unknown=50
    # Headers remain fully dynamic, limits require HAProxy config regeneration
    
    # Premium group - per minute (2000 from map file)
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] (%[var(txn.rate_limit_per_minute)] requests/minute per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_premium_group { sc_http_req_rate(0) gt 2000 }
    
    # Standard group - per minute (500 from map file)
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] (%[var(txn.rate_limit_per_minute)] requests/minute per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_standard_group { sc_http_req_rate(0) gt 500 }
    
    # Basic group - per minute (100 from map file)
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] (%[var(txn.rate_limit_per_minute)] requests/minute per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_basic_group { sc_http_req_rate(0) gt 100 }
    
    # Unknown group - per minute (50 from map file)
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] (%[var(txn.rate_limit_per_minute)] requests/minute per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_unknown_group { sc_http_req_rate(0) gt 50 }
    
    # Burst limits - per second (50, 25, 10, 5 from map file)
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] - burst (%[var(txn.rate_limit_per_second)] requests/second per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_premium_group { sc_http_req_rate(1) gt 50 }
    
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] - burst (%[var(txn.rate_limit_per_second)] requests/second per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_standard_group { sc_http_req_rate(1) gt 25 }
    
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] - burst (%[var(txn.rate_limit_per_second)] requests/second per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_basic_group { sc_http_req_rate(1) gt 10 }
    
    http-request deny deny_status 429 content-type "application/xml" string "<?xml version=\"1.0\" encoding=\"UTF-8\"?><Error><Code>SlowDown</Code><Message>%[var(txn.error_message)] - burst (%[var(txn.rate_limit_per_second)] requests/second per API key)</Message><Resource>%[path]</Resource><RequestId>%[uuid()]</RequestId><ApiKey>%[var(txn.api_key)]</ApiKey></Error>" if rate_limited_methods is_unknown_group { sc_http_req_rate(1) gt 5 }
    
    # Add comprehensive debugging and rate limit headers
    http-request set-header X-Debug-API-Key %[var(txn.api_key)]
    http-request set-header X-Debug-Auth-Method %[var(txn.auth_method)]
    http-request set-header X-Debug-Rate-Group %[var(txn.rate_group)]
    http-request set-header X-Debug-After-Equals %[var(txn.after_equals)]
    http-request set-header X-Debug-Before-Comma %[var(txn.before_comma)]
    http-request set-header X-Request-ID %[uuid()]
    
    # Response headers for rate limiting information
    http-response set-header X-RateLimit-Group "%[var(txn.rate_group)]"
    http-response set-header X-API-Key "%[var(txn.api_key)]"
    http-response set-header X-Auth-Method "%[var(txn.auth_method)]"
    
    # Dynamic rate limit headers (no hardcoded values)
    http-response set-header X-RateLimit-Limit-Per-Minute "%[var(txn.rate_limit_per_minute)]"
    http-response set-header X-RateLimit-Limit-Per-Second "%[var(txn.rate_limit_per_second)]"
    
    http-response set-header X-RateLimit-Current-Per-Minute "%[sc_http_req_rate(0)]"
    http-response set-header X-RateLimit-Current-Per-Second "%[sc_http_req_rate(1)]"
    http-response set-header X-RateLimit-Reset "%[date(),add(3600)]"
    
    default_backend minio_backend

# Backend for MinIO cluster
backend minio_backend
    balance roundrobin
    
    # MinIO server instances
    server minio1 minio:9000

# Stick tables for individual API key rate tracking (no shared limits)
backend api_key_rates_1m
    stick-table type string len 64 size 100k expire 2m store http_req_rate(1m),http_req_cnt,http_err_rate(1m)

backend api_key_rates_1s
    stick-table type string len 64 size 100k expire 10s store http_req_rate(1s),http_req_cnt

# Stats interface for monitoring
listen stats
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 30s
    stats admin if TRUE
    stats show-legends
    stats show-desc "HAProxy MinIO Complete Rate Limiting - Individual API Key Tracking"

