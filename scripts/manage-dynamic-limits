#!/bin/bash

# Dynamic Rate Limit Management Script
# Manages all aspects of rate limiting without hardcoded values
# Usage: ./manage-dynamic-limits [command] [options]

# Set config directory relative to the script's location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="$SCRIPT_DIR/../haproxy/config"
API_GROUPS_MAP="$CONFIG_DIR/api_key_groups.map"
MINUTE_LIMITS_MAP="$CONFIG_DIR/rate_limits_per_minute.map"
SECOND_LIMITS_MAP="$CONFIG_DIR/rate_limits_per_second.map"
ERROR_MESSAGES_MAP="$CONFIG_DIR/error_messages.map"
# NEW: Bandwidth limit map files
DOWNLOAD_LIMITS_MAP="$CONFIG_DIR/bandwidth_limits_download.map"
UPLOAD_LIMITS_MAP="$CONFIG_DIR/bandwidth_limits_upload.map"
BACKUP_DIR="$CONFIG_DIR/backups"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Ensure backup directory exists
mkdir -p "$BACKUP_DIR"

show_help() {
    echo -e "${BLUE}Dynamic Rate Limit Management - Zero Hardcoded Values${NC}"
    echo "Usage: $0 [command] [options]"
    echo ""
    echo "API Key Management:"
    echo "  add-key <key> <group> [--hot-reload]     Add API key to group"
    echo "  remove-key <key> [--hot-reload]          Remove API key"
    echo "  update-key <key> <new_group> [--hot-reload]  Update API key group"
    echo "  list-keys                                List all API keys"
    echo ""
    echo "Request-Based Rate Limiting:"
    echo "  set-minute-limit <group> <limit> [--hot-reload]  Set per-minute request limit for group"
    echo "  set-second-limit <group> <limit> [--hot-reload]  Set per-second request limit for group"
    echo "  get-limits <group>                            Get current limits for group"
    echo "  list-all-limits                               List all rate limits"
    echo ""
    echo "Bandwidth-Based Rate Limiting:"
    echo "  set-download-limit <group> <bytes_or_unit> [--hot-reload]  Set download bandwidth limit"
    echo "  set-upload-limit <group> <bytes_or_unit> [--hot-reload]    Set upload bandwidth limit"
    echo "  get-bandwidth-limits <group>                              Get bandwidth limits for group"
    echo "  show-bandwidth-config                                     Show all bandwidth limits"
    echo ""
    echo "Error Message Management:"
    echo "  set-error-msg <group> <message> [--hot-reload]   Set custom error message"
    echo "  get-error-msg <group>                            Get error message for group"
    echo ""
    echo "System Management:"
    echo "  reload [--hot-reload]           Reload HAProxy configuration"
    echo "  validate                        Validate all map files"
    echo "  backup                          Create backup of all configs"
    echo "  restore <backup_date>           Restore from backup"
    echo "  show-stats                      Show current system status"
    echo ""
    echo "Options:"
    echo "  --hot-reload                    Use HAProxy runtime API to reload maps without process restart"
    echo ""
    echo "Bandwidth Unit Examples:"
    echo "  $0 set-download-limit premium 50M      # 50 MB/s"
    echo "  $0 set-upload-limit standard 10MB      # 10 MB/s"
    echo "  $0 set-download-limit basic 2048000    # 2048000 bytes/s"
    echo ""
}

backup_configs() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_prefix="$BACKUP_DIR/dynamic_config_${timestamp}"

    echo -e "${YELLOW}Creating backup...${NC}"

    [ -f "$API_GROUPS_MAP" ] && cp "$API_GROUPS_MAP" "${backup_prefix}_api_groups.map"
    [ -f "$MINUTE_LIMITS_MAP" ] && cp "$MINUTE_LIMITS_MAP" "${backup_prefix}_minute_limits.map"
    [ -f "$SECOND_LIMITS_MAP" ] && cp "$SECOND_LIMITS_MAP" "${backup_prefix}_second_limits.map"
    [ -f "$ERROR_MESSAGES_MAP" ] && cp "$ERROR_MESSAGES_MAP" "${backup_prefix}_error_messages.map"
    # NEW: Backup bandwidth limit files
    [ -f "$DOWNLOAD_LIMITS_MAP" ] && cp "$DOWNLOAD_LIMITS_MAP" "${backup_prefix}_download_limits.map"
    [ -f "$UPLOAD_LIMITS_MAP" ] && cp "$UPLOAD_LIMITS_MAP" "${backup_prefix}_upload_limits.map"

    echo -e "${GREEN}✅ Backup created: ${timestamp}${NC}"
}

validate_map_files() {
    local errors=0

    echo -e "${BLUE}Validating all map files...${NC}"

    # Check API groups map
    if [ -f "$API_GROUPS_MAP" ]; then
        if ! grep -q '^[A-Z0-9]' "$API_GROUPS_MAP" 2>/dev/null; then
            echo -e "${RED}❌ API groups map appears empty or invalid${NC}"
            errors=$((errors + 1))
        else
            echo -e "${GREEN}✅ API groups map: $(grep -c '^[A-Z0-9]' "$API_GROUPS_MAP") keys${NC}"
        fi
    fi

    # Check rate limit maps
    for map_file in "$MINUTE_LIMITS_MAP" "$SECOND_LIMITS_MAP"; do
        if [ -f "$map_file" ]; then
            if ! grep -qE '^[a-z]+ [0-9]+$' "$map_file" 2>/dev/null; then
                echo -e "${RED}❌ $(basename "$map_file") has invalid format${NC}"
                errors=$((errors + 1))
            else
                echo -e "${GREEN}✅ $(basename "$map_file"): valid${NC}"
            fi
        fi
    done

    return $errors
}

hot_reload_maps() {
    echo -e "${YELLOW}Hot reloading HAProxy maps via runtime API...${NC}"

    local socket_paths=(
        "/tmp/haproxy.sock"
        "/var/run/haproxy.sock"
        "/run/haproxy.sock"
    )

    local maps=(
        "/usr/local/etc/haproxy/config/api_key_groups.map"
        "/usr/local/etc/haproxy/config/rate_limits_per_minute.map"
        "/usr/local/etc/haproxy/config/rate_limits_per_second.map"
        "/usr/local/etc/haproxy/config/error_messages.map"
        "/usr/local/etc/haproxy/config/bandwidth_limits_download.map"
        "/usr/local/etc/haproxy/config/bandwidth_limits_upload.map"
    )

    local success_count=0
    local total_count=0

    # Try Docker containers first
    if docker ps --format "table {{.Names}}" | grep -q "haproxy"; then
        echo "Hot reloading maps in HAProxy containers..."
        for container in $(docker ps --format "{{.Names}}" | grep haproxy); do
            echo "  → $container"
            for map_file in "${maps[@]}"; do
                total_count=$((total_count + 1))
                # Clear and reload each map using proper HAProxy runtime API
                if docker exec "$container" sh -c "echo 'clear map $map_file' | socat stdio /tmp/haproxy.sock" 2>/dev/null && \
                   docker exec "$container" sh -c "cat $map_file | grep -v '^#' | while read key value; do [ -n \"\$key\" ] && [ -n \"\$value\" ] && echo \"add map $map_file \$key \$value\" | socat stdio /tmp/haproxy.sock; done" 2>/dev/null; then
                    echo "    ✅ Reloaded $(basename "$map_file")"
                    success_count=$((success_count + 1))
                else
                    echo "    ⚠️  Failed to reload $(basename "$map_file")"
                fi
            done
        done

        if [ $success_count -gt 0 ]; then
            echo "Successfully reloaded $success_count/$total_count maps"
            return 0
        else
            return 1
        fi
    fi

    # Try local HAProxy socket
    for socket_path in "${socket_paths[@]}"; do
        if [ -S "$socket_path" ]; then
            echo "Using HAProxy socket: $socket_path"
            for map_file in "${maps[@]}"; do
                total_count=$((total_count + 1))
                # Clear and reload each map
                if echo "clear map $map_file" | socat stdio "$socket_path" 2>/dev/null && \
                   cat "$map_file" | grep -v '^#' | while read key value; do [ -n "$key" ] && [ -n "$value" ] && echo "add map $map_file $key $value" | socat stdio "$socket_path"; done 2>/dev/null; then
                    echo "  ✅ Reloaded $(basename "$map_file")"
                    success_count=$((success_count + 1))
                else
                    echo "  ⚠️  Failed to reload $(basename "$map_file")"
                fi
            done

            if [ $success_count -gt 0 ]; then
                echo "Successfully reloaded $success_count/$total_count maps"
                return 0
            else
                return 1
            fi
        fi
    done

    echo -e "${RED}❌ No HAProxy socket found. Falling back to full reload.${NC}"
    return 1
}

reload_haproxy() {
    local use_hot_reload=false

    # Check if --hot-reload flag is present in arguments
    for arg in "$@"; do
        if [ "$arg" = "--hot-reload" ]; then
            use_hot_reload=true
            break
        fi
    done

    if [ "$use_hot_reload" = true ]; then
        if hot_reload_maps; then
            echo -e "${GREEN}✅ HAProxy maps hot reloaded successfully${NC}"
            return 0
        fi
        # If hot reload fails, fall through to full reload
        echo -e "${YELLOW}Falling back to full HAProxy reload...${NC}"
    fi

    echo -e "${YELLOW}Reloading HAProxy configuration...${NC}"

    # Try Docker containers first
    if docker ps --format "table {{.Names}}" | grep -q "haproxy"; then
        echo "Reloading HAProxy containers..."
        for container in $(docker ps --format "{{.Names}}" | grep haproxy); do
            echo "  → $container"
            docker exec "$container" haproxy -f /usr/local/etc/haproxy/haproxy.cfg -sf $(docker exec "$container" pidof haproxy) 2>/dev/null || {
                echo -e "${YELLOW}    Restarting $container${NC}"
                docker restart "$container" >/dev/null
            }
        done
    else
        # Try local HAProxy
        if command -v haproxy >/dev/null 2>&1; then
            sudo haproxy -f haproxy.cfg -sf $(pidof haproxy) 2>/dev/null || {
                echo -e "${YELLOW}HAProxy not running, starting...${NC}"
                sudo haproxy -f haproxy.cfg -D
            }
        else
            echo -e "${RED}❌ HAProxy not found${NC}"
            return 1
        fi
    fi

    echo -e "${GREEN}✅ HAProxy configuration reloaded${NC}"
}

set_minute_limit() {
    local group="$1"
    local limit="$2"
    shift 2  # Remove first two arguments to get remaining flags

    if [ -z "$group" ] || [ -z "$limit" ]; then
        echo -e "${RED}❌ Usage: set-minute-limit <group> <limit> [--hot-reload]${NC}"
        return 1
    fi

    if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}❌ Limit must be a number${NC}"
        return 1
    fi

    backup_configs

    # Update or add the limit
    if grep -q "^$group " "$MINUTE_LIMITS_MAP" 2>/dev/null; then
        sed -i.bak "s/^$group [0-9]*/$group $limit/" "$MINUTE_LIMITS_MAP"
        echo -e "${GREEN}✅ Updated minute limit for $group: $limit${NC}"
    else
        echo "$group $limit" >> "$MINUTE_LIMITS_MAP"
        echo -e "${GREEN}✅ Added minute limit for $group: $limit${NC}"
    fi

    reload_haproxy "$@"  # Pass remaining arguments (including --hot-reload)
}

set_second_limit() {
    local group="$1"
    local limit="$2"
    shift 2  # Remove first two arguments to get remaining flags

    if [ -z "$group" ] || [ -z "$limit" ]; then
        echo -e "${RED}❌ Usage: set-second-limit <group> <limit> [--hot-reload]${NC}"
        return 1
    fi

    if ! [[ "$limit" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}❌ Limit must be a number${NC}"
        return 1
    fi

    backup_configs

    # Update or add the limit
    if grep -q "^$group " "$SECOND_LIMITS_MAP" 2>/dev/null; then
        sed -i.bak "s/^$group [0-9]*/$group $limit/" "$SECOND_LIMITS_MAP"
        echo -e "${GREEN}✅ Updated second limit for $group: $limit${NC}"
    else
        echo "$group $limit" >> "$SECOND_LIMITS_MAP"
        echo -e "${GREEN}✅ Added second limit for $group: $limit${NC}"
    fi

    reload_haproxy "$@"  # Pass remaining arguments (including --hot-reload)
}

get_limits() {
    local group="$1"

    if [ -z "$group" ]; then
        echo -e "${RED}❌ Usage: get-limits <group>${NC}"
        return 1
    fi

    echo -e "${BLUE}Rate limits for group: $group${NC}"

    local minute_limit=$(grep "^$group " "$MINUTE_LIMITS_MAP" 2>/dev/null | awk '{print $2}')
    local second_limit=$(grep "^$group " "$SECOND_LIMITS_MAP" 2>/dev/null | awk '{print $2}')
    local error_msg=$(grep "^$group " "$ERROR_MESSAGES_MAP" 2>/dev/null | cut -d' ' -f2-)

    echo "  Per-minute limit: ${minute_limit:-'not set'}"
    echo "  Per-second limit: ${second_limit:-'not set'}"
    echo "  Error message: ${error_msg:-'not set'}"
}

list_all_limits() {
    echo -e "${BLUE}All Dynamic Rate Limits${NC}"
    echo "========================"

    # Get all unique groups
    local groups=$(cat "$MINUTE_LIMITS_MAP" "$SECOND_LIMITS_MAP" "$ERROR_MESSAGES_MAP" 2>/dev/null | grep -v '^#' | awk '{print $1}' | sort -u)

    printf "%-10s %-12s %-12s %-30s\n" "GROUP" "PER-MINUTE" "PER-SECOND" "ERROR MESSAGE"
    printf "%-10s %-12s %-12s %-30s\n" "------" "----------" "----------" "-------------"

    for group in $groups; do
        local minute_limit=$(grep "^$group " "$MINUTE_LIMITS_MAP" 2>/dev/null | awk '{print $2}')
        local second_limit=$(grep "^$group " "$SECOND_LIMITS_MAP" 2>/dev/null | awk '{print $2}')
        local error_msg=$(grep "^$group " "$ERROR_MESSAGES_MAP" 2>/dev/null | cut -d' ' -f2- | cut -c1-28)

        printf "%-10s %-12s %-12s %-30s\n" "$group" "${minute_limit:-'-'}" "${second_limit:-'-'}" "${error_msg:-'-'}"
    done
}

add_api_key() {
    local key="$1"
    local group="$2"
    shift 2  # Remove first two arguments to get remaining flags

    if [ -z "$key" ] || [ -z "$group" ]; then
        echo -e "${RED}❌ Usage: add-key <key> <group> [--hot-reload]${NC}"
        return 1
    fi

    backup_configs

    # Check if key already exists
    if grep -q "^$key " "$API_GROUPS_MAP" 2>/dev/null; then
        echo -e "${YELLOW}⚠️ Key already exists, updating group...${NC}"
        cat $API_GROUPS_MAP
        ls -lrth $API_GROUPS_MAP
        exit 1
        sed -i.bak "s/^$key .*/$key $group/" "$API_GROUPS_MAP"
    else
        echo "$key $group" >> "$API_GROUPS_MAP"
    fi

    echo -e "${GREEN}✅ API key $key assigned to group: $group${NC}"
    reload_haproxy "$@"  # Pass remaining arguments (including --hot-reload)
}

remove_api_key() {
    local key="$1"
    shift 1  # Remove first argument to get remaining flags

    if [ -z "$key" ]; then
        echo -e "${RED}❌ Usage: remove-key <key> [--hot-reload]${NC}"
        return 1
    fi

    if ! grep -q "^$key " "$API_GROUPS_MAP" 2>/dev/null; then
        echo -e "${RED}❌ API key not found: $key${NC}"
        return 1
    fi

    backup_configs

    # Remove the key
    grep -v "^$key " "$API_GROUPS_MAP" > "$API_GROUPS_MAP.tmp" && mv "$API_GROUPS_MAP.tmp" "$API_GROUPS_MAP"

    echo -e "${GREEN}✅ API key removed: $key${NC}"
    reload_haproxy "$@"  # Pass remaining arguments (including --hot-reload)
}

update_api_key() {
    local key="$1"
    local new_group="$2"
    shift 2  # Remove first two arguments to get remaining flags

    if [ -z "$key" ] || [ -z "$new_group" ]; then
        echo -e "${RED}❌ Usage: update-key <key> <new_group> [--hot-reload]${NC}"
        return 1
    fi

    if ! grep -q "^$key " "$API_GROUPS_MAP" 2>/dev/null; then
        echo -e "${RED}❌ API key not found: $key${NC}"
        return 1
    fi

    local old_group=$(grep "^$key " "$API_GROUPS_MAP" | awk '{print $2}')

    backup_configs

    # Update the key's group
    sed -i.bak "s/^$key .*/$key $new_group/" "$API_GROUPS_MAP"

    echo -e "${GREEN}✅ API key $key updated: $old_group → $new_group${NC}"
    reload_haproxy "$@"  # Pass remaining arguments (including --hot-reload)
}

list_api_keys() {
    if [ ! -f "$API_GROUPS_MAP" ]; then
        echo -e "${RED}❌ No API keys file found${NC}"
        return 1
    fi

    echo -e "${BLUE}All API Keys${NC}"
    echo "============"

    printf "%-25s %-15s\n" "API KEY" "GROUP"
    printf "%-25s %-15s\n" "-------" "-----"

    grep -v '^#' "$API_GROUPS_MAP" 2>/dev/null | sort -k2,2 -k1,1 | while read key group; do
        printf "%-25s %-15s\n" "$key" "$group"
    done

    echo ""
    echo -e "${BLUE}Summary:${NC}"
    grep -v '^#' "$API_GROUPS_MAP" 2>/dev/null | awk '{print $2}' | sort | uniq -c | while read count group; do
        echo "  $group: $count keys"
    done
}

set_error_message() {
    local group="$1"
    local message="$2"
    shift 2  # Remove first two arguments to get remaining flags

    if [ -z "$group" ] || [ -z "$message" ]; then
        echo -e "${RED}❌ Usage: set-error-msg <group> <message> [--hot-reload]${NC}"
        return 1
    fi

    backup_configs

    # Update or add the error message
    if grep -q "^$group " "$ERROR_MESSAGES_MAP" 2>/dev/null; then
        sed -i.bak "s/^$group .*/$group $message/" "$ERROR_MESSAGES_MAP"
        echo -e "${GREEN}✅ Updated error message for $group${NC}"
    else
        echo "$group $message" >> "$ERROR_MESSAGES_MAP"
        echo -e "${GREEN}✅ Added error message for $group${NC}"
    fi

    reload_haproxy "$@"  # Pass remaining arguments (including --hot-reload)
}

get_error_message() {
    local group="$1"

    if [ -z "$group" ]; then
        echo -e "${RED}❌ Usage: get-error-msg <group>${NC}"
        return 1
    fi

    local error_msg=$(grep "^$group " "$ERROR_MESSAGES_MAP" 2>/dev/null | cut -d' ' -f2-)

    if [ -n "$error_msg" ]; then
        echo -e "${BLUE}Error message for group '$group':${NC}"
        echo "  $error_msg"
    else
        echo -e "${YELLOW}⚠️ No custom error message set for group: $group${NC}"
        echo "  (Will use default: Rate_limit_exceeded)"
    fi
}

restore_backup() {
    local backup_date="$1"

    if [ -z "$backup_date" ]; then
        echo -e "${RED}❌ Usage: restore <backup_date>${NC}"
        echo -e "${BLUE}Available backups:${NC}"
        ls -1 "$BACKUP_DIR" | grep -E "_[0-9]{8}_[0-9]{6}_" | sed 's/dynamic_config_\([0-9_]*\)_.*/\1/' | sort -u
        return 1
    fi

    local backup_files=$(ls "$BACKUP_DIR"/dynamic_config_${backup_date}_*.map 2>/dev/null)

    if [ -z "$backup_files" ]; then
        echo -e "${RED}❌ No backup found for date: $backup_date${NC}"
        return 1
    fi

    echo -e "${YELLOW}Restoring configuration from backup: $backup_date${NC}"

    # Create current backup before restoring
    backup_configs

    # Restore each file
    for backup_file in $backup_files; do
        local basename=$(basename "$backup_file")
        case "$basename" in
            *_api_groups.map)
                cp "$backup_file" "$API_GROUPS_MAP"
                echo -e "${GREEN}✅ Restored API groups${NC}"
                ;;
            *_minute_limits.map)
                cp "$backup_file" "$MINUTE_LIMITS_MAP"
                echo -e "${GREEN}✅ Restored minute limits${NC}"
                ;;
            *_second_limits.map)
                cp "$backup_file" "$SECOND_LIMITS_MAP"
                echo -e "${GREEN}✅ Restored second limits${NC}"
                ;;
            *_error_messages.map)
                cp "$backup_file" "$ERROR_MESSAGES_MAP"
                echo -e "${GREEN}✅ Restored error messages${NC}"
                ;;
            *_download_limits.map)
                cp "$backup_file" "$DOWNLOAD_LIMITS_MAP"
                echo -e "${GREEN}✅ Restored download bandwidth limits${NC}"
                ;;
            *_upload_limits.map)
                cp "$backup_file" "$UPLOAD_LIMITS_MAP"
                echo -e "${GREEN}✅ Restored upload bandwidth limits${NC}"
                ;;
        esac
    done

    echo -e "${YELLOW}Validating restored configuration...${NC}"
    if validate_map_files; then
        reload_haproxy
        echo -e "${GREEN}✅ Configuration restored successfully${NC}"
    else
        echo -e "${RED}❌ Restored configuration has errors${NC}"
        return 1
    fi
}

# NEW: Bandwidth limiting functions
convert_to_bytes() {
    local value="$1"
    local num unit
    
    # Extract number and unit - handle both MB and M formats
    if [[ $value =~ ^([0-9]+)([KMG]?)B?$ ]]; then
        num=${BASH_REMATCH[1]}
        unit=${BASH_REMATCH[2]}
        
        case $unit in
            "K") echo $((num * 1024)) ;;
            "M") echo $((num * 1048576)) ;;
            "G") echo $((num * 1073741824)) ;;
            "") echo $num ;;  # No unit, assume bytes
            *) echo "❌ Invalid unit: $unit" >&2; return 1 ;;
        esac
    else
        echo "❌ Invalid format: $value. Use format like: 50M, 1024K, or plain number for bytes" >&2
        return 1
    fi
}

format_bytes() {
    local bytes=$1
    if (( bytes >= 1073741824 )); then
        echo "$((bytes / 1073741824)) GB/s"
    elif (( bytes >= 1048576 )); then
        echo "$((bytes / 1048576)) MB/s"
    elif (( bytes >= 1024 )); then
        echo "$((bytes / 1024)) KB/s"
    else
        echo "$bytes bytes/s"
    fi
}

set_download_limit() {
    local group="$1"
    local limit_input="$2"
    shift 2  # Remove first two arguments to get remaining flags
    
    if [ -z "$group" ] || [ -z "$limit_input" ]; then
        echo -e "${RED}❌ Usage: set-download-limit <group> <bytes_or_unit> [--hot-reload]${NC}"
        echo "Examples: 50M, 1024K, 2097152"
        return 1
    fi
    
    local limit_bytes
    if [[ "$limit_input" =~ ^[0-9]+$ ]]; then
        limit_bytes=$limit_input
    else
        limit_bytes=$(convert_to_bytes "$limit_input")
        if [ $? -ne 0 ]; then
            return 1
        fi
    fi
    
    backup_configs
    
    # Update or add the limit
    if grep -q "^$group " "$DOWNLOAD_LIMITS_MAP" 2>/dev/null; then
        sed -i.bak "s/^$group [0-9]*/$group $limit_bytes/" "$DOWNLOAD_LIMITS_MAP"
        echo -e "${GREEN}✅ Updated download limit for $group: $(format_bytes $limit_bytes)${NC}"
    else
        echo "$group $limit_bytes" >> "$DOWNLOAD_LIMITS_MAP"
        echo -e "${GREEN}✅ Added download limit for $group: $(format_bytes $limit_bytes)${NC}"
    fi
    
    reload_haproxy "$@"
}

set_upload_limit() {
    local group="$1"
    local limit_input="$2"
    shift 2  # Remove first two arguments to get remaining flags
    
    if [ -z "$group" ] || [ -z "$limit_input" ]; then
        echo -e "${RED}❌ Usage: set-upload-limit <group> <bytes_or_unit> [--hot-reload]${NC}"
        echo "Examples: 25M, 512K, 1048576"
        return 1
    fi
    
    local limit_bytes
    if [[ "$limit_input" =~ ^[0-9]+$ ]]; then
        limit_bytes=$limit_input
    else
        limit_bytes=$(convert_to_bytes "$limit_input")
        if [ $? -ne 0 ]; then
            return 1
        fi
    fi
    
    backup_configs
    
    # Update or add the limit
    if grep -q "^$group " "$UPLOAD_LIMITS_MAP" 2>/dev/null; then
        sed -i.bak "s/^$group [0-9]*/$group $limit_bytes/" "$UPLOAD_LIMITS_MAP"
        echo -e "${GREEN}✅ Updated upload limit for $group: $(format_bytes $limit_bytes)${NC}"
    else
        echo "$group $limit_bytes" >> "$UPLOAD_LIMITS_MAP"
        echo -e "${GREEN}✅ Added upload limit for $group: $(format_bytes $limit_bytes)${NC}"
    fi
    
    reload_haproxy "$@"
}

get_bandwidth_limits() {
    local group="$1"
    
    if [ -z "$group" ]; then
        echo -e "${RED}❌ Usage: get-bandwidth-limits <group>${NC}"
        return 1
    fi
    
    echo -e "${BLUE}Bandwidth limits for group: $group${NC}"
    
    local download_limit=$(grep "^$group " "$DOWNLOAD_LIMITS_MAP" 2>/dev/null | awk '{print $2}')
    local upload_limit=$(grep "^$group " "$UPLOAD_LIMITS_MAP" 2>/dev/null | awk '{print $2}')
    
    if [ -n "$download_limit" ]; then
        echo "  Download limit: $(format_bytes $download_limit)"
    else
        echo "  Download limit: not set"
    fi
    
    if [ -n "$upload_limit" ]; then
        echo "  Upload limit: $(format_bytes $upload_limit)"
    else
        echo "  Upload limit: not set"
    fi
}

show_bandwidth_config() {
    echo -e "${BLUE}🌐 BANDWIDTH RATE LIMITS CONFIGURATION${NC}"
    echo "======================================="
    echo ""
    echo -e "${GREEN}📥 DOWNLOAD LIMITS:${NC}"
    if [ -f "$DOWNLOAD_LIMITS_MAP" ]; then
        cat "$DOWNLOAD_LIMITS_MAP" | grep -v '^#' | while read group limit; do
            [[ -z "$group" ]] && continue
            echo "  $group: $(format_bytes $limit)"
        done
    else
        echo "  No download limits configured"
    fi
    echo ""
    echo -e "${GREEN}📤 UPLOAD LIMITS:${NC}"
    if [ -f "$UPLOAD_LIMITS_MAP" ]; then
        cat "$UPLOAD_LIMITS_MAP" | grep -v '^#' | while read group limit; do
            [[ -z "$group" ]] && continue
            echo "  $group: $(format_bytes $limit)"
        done
    else
        echo "  No upload limits configured"  
    fi
}

show_stats() {
    echo -e "${BLUE}Dynamic Rate Limiting System Status${NC}"
    echo "==================================="

    # Count API keys by group
    if [ -f "$API_GROUPS_MAP" ]; then
        echo -e "${GREEN}API Keys by Group:${NC}"
        grep -v '^#' "$API_GROUPS_MAP" 2>/dev/null | awk '{print $2}' | sort | uniq -c | while read count group; do
            echo "  $group: $count keys"
        done
        echo "  Total: $(grep -c -v '^#' "$API_GROUPS_MAP" 2>/dev/null || echo 0) keys"
    fi

    echo ""
    list_all_limits
    
    echo ""
    show_bandwidth_config

    echo ""
    echo -e "${BLUE}Map Files Status:${NC}"
    for file in "$API_GROUPS_MAP" "$MINUTE_LIMITS_MAP" "$SECOND_LIMITS_MAP" "$ERROR_MESSAGES_MAP" "$DOWNLOAD_LIMITS_MAP" "$UPLOAD_LIMITS_MAP"; do
        if [ -f "$file" ]; then
            echo -e "${GREEN}✅ $(basename "$file")${NC}"
        else
            echo -e "${RED}❌ $(basename "$file")${NC}"
        fi
    done
}

# Main command handler
case "$1" in
    "add-key")
        shift  # Remove command name
        add_api_key "$@"
        ;;
    "remove-key")
        shift  # Remove command name
        remove_api_key "$@"
        ;;
    "update-key")
        shift  # Remove command name
        update_api_key "$@"
        ;;
    "list-keys")
        list_api_keys
        ;;
    "set-minute-limit")
        shift  # Remove command name
        set_minute_limit "$@"
        ;;
    "set-second-limit")
        shift  # Remove command name
        set_second_limit "$@"
        ;;
    "get-limits")
        get_limits "$2"
        ;;
    "list-all-limits")
        list_all_limits
        ;;
    "set-error-msg")
        shift  # Remove command name
        set_error_message "$@"
        ;;
    "get-error-msg")
        get_error_message "$2"
        ;;
    "reload")
        shift  # Remove command name
        reload_haproxy "$@"
        ;;
    "validate")
        validate_map_files
        ;;
    "backup")
        backup_configs
        ;;
    "restore")
        restore_backup "$2"
        ;;
    "set-download-limit")
        shift  # Remove command name
        set_download_limit "$@"
        ;;
    "set-upload-limit")
        shift  # Remove command name
        set_upload_limit "$@"
        ;;
    "get-bandwidth-limits")
        get_bandwidth_limits "$2"
        ;;
    "show-bandwidth-config")
        show_bandwidth_config
        ;;
    "show-stats")
        show_stats
        ;;
    *)
        show_help
        ;;
esac
