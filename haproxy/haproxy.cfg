global
    daemon
    maxconn 8192  # Increased from 4096
    log stdout local0 info

    # Performance tuning
    tune.bufsize 32768          # Increased buffer size
    tune.maxrewrite 2048        # Increased rewrite buffer
    tune.http.maxhdr 200        # Increased max headers
    tune.lua.maxmem 1024        # Increased Lua memory limit (1MB)

    # Optimized Lua scripts
    lua-load /usr/local/etc/haproxy/extract_api_keys.lua
    lua-load /usr/local/etc/haproxy/dynamic_rate_limiter.lua

    # Stats socket for runtime API
    stats socket /tmp/haproxy.sock mode 666 level admin
    stats timeout 30s

defaults
    mode http
    timeout connect 2000ms      # Reduced from 5000ms
    timeout client 30000ms      # Reduced from 50000ms
    timeout server 30000ms      # Reduced from 50000ms
    option httplog
    option http-keep-alive      # Enable keep-alive for performance
    option dontlognull         # Don't log health checks
    log global

# Frontend for S3 API requests with OPTIMIZED rate limiting
frontend s3_frontend_optimized
    bind *:80
    bind *:443 ssl crt /etc/ssl/certs/haproxy.pem

    # Performance optimizations
    option httpclose           # Close connections to free memory faster
    maxconn 4096              # Limit connections per frontend

    # Extract API key and set rate limiting variables using optimized Lua
    http-request lua.extract_api_key

    # Map API key to rate group and set all rate limiting values using Lua
    # This replaces the former map directives below
    http-request lua.map_api_key_to_group

    # Only load rate limits if we have an API key (performance optimization)
    http-request track-sc0 var(txn.api_key) table api_key_rates_1m if { method PUT GET }
    http-request track-sc1 var(txn.api_key) table api_key_rates_1s if { method PUT GET }

    # Optimized rate limiting using Lua (only for PUT/GET)
    http-request lua.check_rate_limit if { method PUT GET }

    # Deny request if rate limit exceeded (fast check)
    http-request deny deny_status 429 content-type "application/xml" lf-string "%[var(txn.rate_limit_error)]" if { var(txn.rate_limit_exceeded) -m str true }


    # Response headers for rate limiting information (only when API key exists and has content)
    http-response set-header X-RateLimit-Group "%[var(txn.rate_group)]" if { var(txn.api_key) -m found } { var(txn.api_key) -m len 1: }

    http-response set-header X-API-Key "%[var(txn.api_key)]" if { var(txn.api_key) -m found } { var(txn.api_key) -m len 1: }

    http-response set-header X-Auth-Method "%[var(txn.auth_method)]" if { var(txn.api_key) -m found } { var(txn.api_key) -m len 1: }


    # Dynamic rate limit headers (only when rate limiting was checked)
    http-response set-header X-RateLimit-Limit-Per-Minute "%[var(txn.rate_limit_per_minute)]" if { var(txn.rate_limit_per_minute) -m found }

    http-response set-header X-RateLimit-Limit-Per-Second "%[var(txn.rate_limit_per_second)]" if { var(txn.rate_limit_per_second) -m found }

    http-response set-header X-RateLimit-Limit "%[var(txn.rate_limit_per_minute)]" if { var(txn.rate_limit_per_minute) -m found }

    # Set current usage headers
    http-response set-header X-RateLimit-Current-Per-Minute "%[sc_http_req_rate(0)]" if { method PUT GET }

    http-response set-header X-RateLimit-Current-Per-Second "%[sc_http_req_rate(1)]" if { method PUT GET }

    # Calculate and add X-RateLimit-Remaining directly to avoid bugs
    http-request set-var(txn.current_rate) sc_http_req_rate(0) if { method PUT GET }

    http-request lua.calc_remaining_requests if { method PUT GET }

    http-response set-header X-RateLimit-Remaining "%[var(txn.rate_limit_remaining)]" if { method PUT GET }

    http-response set-header X-RateLimit-Reset "%[date(),add(60)]" if { method PUT GET }

    default_backend minio_backend

# Backend for MinIO cluster
backend minio_backend
    balance roundrobin

    # Performance optimizations
    option http-keep-alive                 # Backend keep-alive

    # MinIO server instances
    server minio1 minio:9000

# Optimized stick tables for API key rate tracking
backend api_key_rates_1m
    # Reduced table size for better memory usage
    stick-table type string len 32 size 50k expire 90s store http_req_rate(1m),http_req_cnt

backend api_key_rates_1s
    # Reduced table size and expire time
    stick-table type string len 32 size 50k expire 5s store http_req_rate(1s),http_req_cnt

# Stats interface for monitoring
listen stats_optimized
    bind *:8404
    stats enable
    stats uri /stats
    stats refresh 15s          # Faster refresh for better monitoring
    stats admin if TRUE
    stats show-legends
    stats show-desc "HAProxy MinIO Optimized Rate Limiting"
