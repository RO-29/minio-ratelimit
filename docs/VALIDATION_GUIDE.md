# MinIO Rate Limiting Validation Guide

This document provides a comprehensive guide for validating and testing the MinIO rate limiting solution using HAProxy and Lua scripts.

## Overview

The MinIO rate limiting solution uses HAProxy 3.0 with Lua 5.3 scripts to implement API-based rate limiting for MinIO S3 API requests. The solution includes:

1. HAProxy configuration for routing and rate limiting
2. Lua scripts for dynamic rate limit control
3. Test tools for validation and performance testing
4. Comprehensive validation scripts

## Prerequisites

- HAProxy 3.0 or later (locally or via Docker)
- Lua 5.3 or later (locally or via Docker)
- Go 1.24 or later (for building test tools)
- Docker and Docker Compose (for running the complete stack)
- 4GB+ RAM (for HAProxy stick tables)
- SSL certificates (auto-generated by provided scripts)

## Path Management

All validation scripts and tools automatically determine the project directory using `PROJECT_ROOT` or `PROJECT_DIR` variables defined in `versions.mk`. Scripts include fallback logic to use the current directory if these variables are not set:

```bash
# Script example of path resolution
if [ -z "$PROJECT_ROOT" ]; then
    PROJECT_ROOT="$(pwd)"
fi
```

This approach ensures that validation tools work correctly regardless of which directory they are executed from.

## Validation Process

### 1. Complete Validation Suite

Run the complete validation suite to verify all components:

```bash
./scripts/verify_all.sh
```

This script will:

- Check for required tools (Go, Docker, HAProxy, Lua)
- Detect Docker Compose version (v1/v2)
- Validate HAProxy configurations
- Validate Lua scripts
- Build the rate limit testing tool
- Generate test tokens
- Run comprehensive validation tests
- Verify the complete setup

The validation suite supports both local and Docker-based validation, automatically falling back to Docker if local tools are not available.

### 2. CI/CD Validation

For CI environments, use the specialized CI targets:

```bash
# Setup CI environment (detects Docker Compose, generates service accounts)
make ci-setup

# Run CI-specific validation (proper output formatting, no colors)
make ci-validate  

# Run CI-specific tests (proper path resolution, coverage generation)
make ci-test

# Complete validation suite for CI
make validate-all
```

These commands are designed for automated environments and include:
- Docker Compose version detection (v1 vs v2)
- Minimal service account generation for testing
- Proper path resolution for CI artifacts
- No colored output for better CI log readability

### 3. Individual Validation Steps

#### Validate HAProxy Configuration

```bash
make lint-haproxy
```

or directly use:

```bash
./scripts/haproxy_validate.sh
```

This validates that:

- HAProxy configuration syntax is correct
- Required rate limiting directives are present
- HAProxy version is compatible (3.0+)
- SSL configuration is valid
- Map files are properly referenced

#### Validate Lua Scripts

```bash
make lint-lua
```

or directly use:

```bash
./scripts/lua_validate.sh
```

This validates that:

- Lua scripts have correct syntax
- Required rate limiting functions are present
- Lua version is compatible (5.3+)
- Authentication extraction logic is valid
- Rate limiting functions are properly implemented

#### Validate Complete Rate Limiting Setup

```bash
make validate-ratelimit
```

This validates the complete rate limiting setup:

- HAProxy configuration is valid
- Lua scripts are valid
- Rate limiting directives are properly configured
- Test tokens can be generated
- Rate limiting test tool can be built

### 3. Testing the Rate Limiting Functionality

#### Generate Test Tokens

```bash
make ratelimit-tokens
```

This generates test tokens with different rate limits for testing.

#### Build the Rate Limiting Test Tool

```bash
make ratelimit-test-build
```

This builds the Go-based test tool for testing rate limiting.

#### Run Basic Tests

```bash
make test-basic        # Test basic tier accounts
make test-standard     # Test standard tier accounts
make test-premium      # Test premium tier accounts
```

#### Run Advanced Tests

```bash
make test-quick        # Run a quick test (15s)
make test-extended     # Run an extended test (5m)
make test-stress       # Run a stress test to find limits
make test-export       # Export detailed test results to JSON
make test-all-tiers    # Test all tiers with comprehensive analysis
```

## Project Organization

The validation tools are part of a well-organized project structure:

```
minio-ratelimit/
├── scripts/                       # Validation and utility scripts
│   ├── verify_all.sh              # Complete validation suite
│   ├── haproxy_validate.sh        # HAProxy configuration validator
│   ├── lua_validate.sh            # Lua scripts syntax validator
│   ├── test_haproxy.sh            # HAProxy configuration tester
│   ├── cleanup.sh                 # Project organization and cleanup utility
│   └── check_docker_compose.sh    # Docker Compose version checker
├── cmd/ratelimit-test/            # Rate limiting test tool
├── Makefile                       # Validation targets
├── linting_targets.mk             # Linting and validation targets
└── ratelimit_targets.mk           # Rate limiting test targets
```

## Troubleshooting

### HAProxy Validation Issues

If HAProxy validation fails:

1. Check that HAProxy 3.0+ is installed or Docker is available
2. Verify HAProxy configuration syntax
3. Ensure rate limiting directives (stick-table, lua-load) are present
4. Check for custom HTTP headers for rate limiting
5. Run `./scripts/haproxy_validate.sh --verbose` for detailed diagnostics

### Lua Script Issues

If Lua validation fails:

1. Check that Lua 5.3+ is installed or Docker is available
2. Verify Lua script syntax
3. Ensure required functions (rate_limit, extract_api_key) are present
4. Check for proper error handling in Lua scripts
5. Run `./scripts/lua_validate.sh --verbose` for detailed diagnostics

### Rate Limiting Not Working

If rate limiting is not working as expected:

1. Verify HAProxy is correctly processing API keys
2. Check that stick tables are correctly configured
3. Verify Lua scripts are correctly loaded
4. Test with different rate limits to ensure thresholds are working

### CI/CD Pipeline Issues

If CI validation fails, follow these troubleshooting steps:

#### Service Account Generation Failures
```bash
# Test Docker Compose detection locally
./scripts/generate-minio-service-accounts.sh

# Check if Docker Compose is available
docker compose version || docker-compose --version

# Manually trigger CI setup
make ci-setup
```

**Common causes:**
- Docker daemon not running in CI environment
- Docker Compose command not found or not in PATH
- Insufficient permissions to create files in CI environment

#### Test Path Resolution Issues
```bash
# Verify test results directory creation
make ensure-results-dir

# Test the same paths used by CI
cd cmd/ratelimit-test
go build -o build/minio-ratelimit-test *.go
./build/minio-ratelimit-test -duration=15s -accounts=2 > ../../test-results/quick_results.json

# Check if files were created
ls -la ../../test-results/
```

**Common causes:**
- Incorrect relative paths when changing directories
- Test results directory not created before writing files
- Permissions issues in CI environment

#### Version Mismatch Errors
```bash
# Simulate CI version validation locally
source ./scripts/export_versions.sh
make check-versions
make verify-versions

# Check specific version files
grep GO_VERSION versions.mk
find . -name "go.mod" -exec grep "^go " {} +
```

**Common causes:**
- `versions.mk` not updated after dependency changes
- Go modules referencing incorrect Go version
- HAProxy version references out of sync

#### Go Slice Bounds Panics
```bash
# Test with empty API keys (common CI issue)
cd cmd/ratelimit-test
go test -v ./... 

# Check for unsafe string slicing
grep -r "accessKey\[:8\]" . || echo "Safe slicing implemented"
```

**Common causes:**
- Empty API keys in test configurations
- Unsafe string slicing without length checks
- Test data generation not handling edge cases

#### Coverage and Artifact Issues
```bash
# Test coverage generation locally
make ci-test

# Verify coverage file paths
ls -la ./test-results/coverage.out
ls -la ./cmd/ratelimit-test/coverage.out

# Test artifact paths used by CI
ls -la ./test-results/
```

**Common causes:**
- Coverage files generated in wrong directory
- Artifact upload paths don't match actual file locations
- Path resolution differs between local and CI environments

### Local CI Simulation

To simulate the complete CI workflow locally:

```bash
# Run the full CI pipeline locally
make ci-setup       # Same as CI setup job
make ci-validate    # Same as CI lint job  
make ci-test        # Same as CI test job
make validate-all   # Same as CI integration-test job
make up
make test-quick
make down
make verify-versions # Same as CI build job
```

This allows you to catch CI issues before pushing changes.

### CI Debugging Commands

Useful commands for debugging CI-specific issues:

```bash
# Check Docker Compose command detection
scripts/generate-minio-service-accounts.sh --dry-run

# Verify version extraction like CI does
source ./scripts/export_versions.sh && env | grep VERSION

# Test service account generation in CI mode
CI=true make ci-setup

# Validate path handling
make test-quick && ls -la test-results/

# Check for slice bounds issues
cd cmd/ratelimit-test && go test -race ./...
```

## References

- [HAProxy Documentation](https://www.haproxy.com/documentation/)
- [Lua 5.3 Reference Manual](https://www.lua.org/manual/5.3/)
- [MinIO S3 API Reference](https://min.io/docs/minio/linux/reference/minio-server/minio-server.html)
- [HAProxy Rate Limiting Guide](https://www.haproxy.com/blog/four-examples-of-haproxy-rate-limiting/)
